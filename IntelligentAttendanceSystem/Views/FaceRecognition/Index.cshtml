@* Views/FaceRecognition/Index.cshtml *@
@{
    ViewData["Title"] = "Face Recognition";
    Layout = "_Layout";
}
<style>
    .channel-card {
        transition: all 0.3s ease;
        border: 2px solid #dee2e6;
    }

        .channel-card.running {
            border-color: #198754;
            background-color: rgba(25, 135, 84, 0.05);
        }

        .channel-card.stopped {
            border-color: #dc3545;
            background-color: rgba(220, 53, 69, 0.05);
        }

        .channel-card .card-header {
            font-weight: bold;
        }

    .status-indicator {
        width: 12px;
        height: 12px;
        border-radius: 50%;
        display: inline-block;
        margin-right: 8px;
    }

    .status-running {
        background-color: #198754;
    }

    .status-stopped {
        background-color: #dc3545;
    }

    .event-log-container {
        height: 300px;
        overflow-y: auto;
        border: 1px solid #dee2e6;
        border-radius: 0.375rem;
        padding: 1rem;
        background-color: #f8f9fa;
        font-family: 'Courier New', monospace;
        font-size: 0.875rem;
    }

    .event-log-item {
        padding: 0.25rem 0;
        border-bottom: 1px solid #e9ecef;
    }

        .event-log-item:last-child {
            border-bottom: none;
        }

    .event-log-time {
        color: #6c757d;
        font-weight: bold;
        margin-right: 0.5rem;
    }

    .event-log-message {
        color: #212529;
    }

    .btn-channel {
        min-width: 80px;
    }

    .channel-stats {
        font-size: 0.875rem;
    }

        .channel-stats .stat-item {
            padding: 2px 0;
            border-bottom: 1px solid #f8f9fa;
        }

            .channel-stats .stat-item:last-child {
                border-bottom: none;
            }

    .bi-arrow-clockwise.spin {
        animation: spin 1s linear infinite;
    }

    .card-footer {
        background-color: rgba(0, 0, 0, 0.03);
        font-size: 0.75rem;
    }

    @@keyframes spin {
        from {
            transform: rotate(0deg);
        }

        to {
            transform: rotate(360deg);
        }
    }
</style>
<div class="container-fluid">
    <div class="row">
        <div class="col-12">
            <div class="card">
                <div class="card-header bg-primary text-white">
                    <h4 class="mb-0"><i class="fas fa-user-circle"></i> Real-time Face Recognition</h4>
                </div>
                <div class="card-body">
                    <!-- Channel Controls -->
                    <div class="row mb-4">
                        <div class="col-md-6">
                            <div class="card">
                                <div class="card-header">
                                    <h5 class="card-title mb-0">Channel Controls</h5>
                                </div>
                                <div class="card-body">
                                    <div class="row mb-3">
                                        <div class="col-md-8">
                                            <label for="channelSelect" class="form-label">Select Channel:</label>
                                            <select class="form-select" id="channelSelect">
                                                @for (int i = 0; i < Model.chnl; i++)
                                                {
                                                    <option value="@i">Channel @(i + 1)</option>
                                                }
                                            </select>
                                        </div>
                                        <div class="col-md-4 d-flex align-items-end">
                                            <button type="button" class="btn btn-primary w-100" onclick="startSelectedChannel()">
                                                Start Selected
                                            </button>
                                        </div>
                                    </div>
                                    <div class="row">
                                        <div class="col-6">
                                            <button type="button" class="btn btn-success w-100" onclick="startAllChannels()">
                                                Start All Channels
                                            </button>
                                        </div>
                                        <div class="col-6">
                                            <button type="button" class="btn btn-danger w-100" onclick="stopAllChannels()">
                                                Stop All Channels
                                            </button>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div class="col-md-6">
                            <div class="card">
                                <div class="card-header">
                                    <h5 class="card-title mb-0">System Status</h5>
                                </div>
                                <div class="card-body">
                                    <div id="systemStatus">
                                        <div class="d-flex justify-content-between align-items-center mb-2">
                                            <span>Device Connection:</span>
                                            <span id="deviceStatus" class="badge bg-secondary">Checking...</span>
                                        </div>
                                        <div class="d-flex justify-content-between align-items-center">
                                            <span>Active Channels:</span>
                                            <span id="activeChannelsCount" class="badge bg-info">0</span>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Channels Grid -->
                    <div class="row" id="channelsGrid">
                        <!-- Channel cards will be dynamically generated here -->
                    </div>



                    <div class="row mb-4">
                        <div class="col-md-6">
                            @if (User.IsInRole("Admin"))
                            {
                                <div class="btn-group" role="group">
                                    <button id="startBtn" class="btn btn-success">
                                        <i class="fas fa-play"></i> Start Recognition
                                    </button>
                                    <button id="stopBtn" class="btn btn-danger" disabled>
                                        <i class="fas fa-stop"></i> Stop Recognition
                                    </button>
                                </div>
                            }
                            <div class="mt-2">
                                <label class="form-label">Channel:</label>
                                <select id="channelSelect" class="form-select" style="width: auto; display: inline-block;">
                                    @for (int i = 0; i < Model.chnl; i++)
                                    {
                                        <option value="@i">Channel @(i + 1)</option>
                                    }
                                </select>
                            </div>
                        </div>
                        <div class="col-md-6">
                            <div id="statusPanel" class="alert alert-info">
                                <i class="fas fa-info-circle"></i> Status: <span id="statusText">Not Started</span>
                                <br>
                                <small>Analyzer ID: <span id="analyzerId">-</span></small>
                            </div>
                        </div>
                    </div>

                    <div class="row">
                        <!-- Global Scene Image -->
                        <div class="col-md-4">
                            <div class="card">
                                <div class="card-header">
                                    <h5 class="card-title mb-0">Global Scene</h5>
                                </div>
                                <div class="card-body text-center">
                                    <img id="globalImage" src="" style="max-width: 100%; max-height: 300px; display: none;"
                                         class="img-fluid border" alt="Global Scene" />
                                    <div id="noGlobalImage" class="text-muted">
                                        No image available
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Detected Face Image -->
                        <div class="col-md-4">
                            <div class="card">
                                <div class="card-header">
                                    <h5 class="card-title mb-0">Detected Face</h5>
                                </div>
                                <div class="card-body text-center">
                                    <img id="faceImage" src="" style="max-width: 100%; max-height: 300px; display: none;"
                                         class="img-fluid border" alt="Detected Face" />
                                    <div id="noFaceImage" class="text-muted">
                                        No face detected
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Candidate Face Image -->
                        <div class="col-md-4">
                            <div class="card">
                                <div class="card-header">
                                    <h5 class="card-title mb-0">Matched Candidate</h5>
                                </div>
                                <div class="card-body text-center">
                                    <img id="candidateImage" src="" style="max-width: 100%; max-height: 300px; display: none;"
                                         class="img-fluid border" alt="Candidate Face" />
                                    <div id="noCandidateImage" class="text-muted">
                                        No match found
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Face Attributes -->
                    <div class="row mt-4">
                        <div class="col-md-6">
                            <div class="card">
                                <div class="card-header">
                                    <h5 class="card-title mb-0">Face Attributes</h5>
                                </div>
                                <div class="card-body">
                                    <table class="table table-sm" id="faceAttributesTable">
                                        <tr><td>Sex:</td><td id="faceSex">-</td></tr>
                                        <tr><td>Age:</td><td id="faceAge">-</td></tr>
                                        <tr><td>Skin Color:</td><td id="faceSkinColor">-</td></tr>
                                        <tr><td>Eye State:</td><td id="faceEye">-</td></tr>
                                        <tr><td>Mouth State:</td><td id="faceMouth">-</td></tr>
                                        <tr><td>Mask State:</td><td id="faceMask">-</td></tr>
                                        <tr><td>Beard State:</td><td id="faceBeard">-</td></tr>
                                        <tr><td>Face Quality:</td><td id="faceQuality">-</td></tr>
                                    </table>
                                </div>
                            </div>
                        </div>

                        <!-- Candidate Information -->
                        <div class="col-md-6">
                            <div class="card">
                                <div class="card-header">
                                    <h5 class="card-title mb-0">Candidate Information</h5>
                                </div>
                                <div class="card-body">
                                    <table class="table table-sm" id="candidateInfoTable">
                                        <tr><td>Name:</td><td id="candidateName">-</td></tr>
                                        <tr><td>ID:</td><td id="candidateId">-</td></tr>
                                        <tr><td>Sex:</td><td id="candidateSex">-</td></tr>
                                        <tr><td>Birthday:</td><td id="candidateBirthday">-</td></tr>
                                        <tr><td>Similarity:</td><td id="candidateSimilarity">-</td></tr>
                                        <tr><td>Group ID:</td><td id="candidateGroupId">-</td></tr>
                                        <tr><td>Group Name:</td><td id="candidateGroupName">-</td></tr>
                                    </table>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="row mt-4">
                        <div class="col-12">

                            <div class="card">
                                <div class="card-header">
                                    <h5 class="card-title mb-0">Vehicle Count</h5>
                                </div>
                                <div class="card-body">
                                    <div id="trafficViolations" style="max-height: 200px; overflow-y: auto;">
                                        <div class="text-muted">No Vehicle COunt yet...</div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <!-- Event Log -->
                    <div class="row mt-4">
                        <div class="col-12">
                            <div class="card">
                                <div class="card-header d-flex justify-content-between align-items-center">
                                    <h5 class="card-title mb-0">Event Log</h5>
                                    <button type="button" class="btn btn-sm btn-outline-secondary" onclick="clearEventLog()">
                                        Clear Log
                                    </button>
                                </div>
                                <div class="card-body">
                                    <div id="eventLog" style="max-height: 200px; overflow-y: auto;">
                                        <div class="text-muted">No events yet...</div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

@section Scripts {
    <script src="https://cdnjs.cloudflare.com/ajax/libs/microsoft-signalr/7.0.10/signalr.min.js"></script>
    <script>
        let isRunning = false;
         let statusCheckInterval;
         let connection;
         let reconnectAttempts = 0;
         const maxReconnectAttempts = 5;
         let isManuallyDisconnected = false;
         const CHANNELS = Array.from({ length: @(Model.chnl) }, (_, i) => i);
         // Initialize SignalR connection
        async function initializeSignalR() {
            if (isManuallyDisconnected) return;

            try {
                connection = new signalR.HubConnectionBuilder()
                    .withUrl("/faceRecognitionHub")
                    .withAutomaticReconnect({
                        nextRetryDelayInMilliseconds: retryContext => {
                            // Exponential backoff: 1s, 2s, 5s, 10s, 30s then stop
                            if (retryContext.previousRetryCount >= maxReconnectAttempts) {
                                return null; // Stop retrying
                            }
                            return [1000, 2000, 5000, 10000, 30000][retryContext.previousRetryCount];
                        }
                    })
                    .configureLogging(signalR.LogLevel.Warning)
                    .build();

                // Connection event handlers
                connection.on("ConnectionStatus", (status) => {
                    console.log('Connection status:', status);
                    addEventLog(status.Message, 'success');
                    updateConnectionStatus(true);
                });

                connection.on("FaceRecognitionEvent", (faceEvent) => {
                    updateFaceRecognitionUI(faceEvent);
                    addEventLog(`Face recognized: ${faceEvent.candidateInfo?.name || 'Unknown'} (${faceEvent.similarity}% similarity)`);
                });

                connection.on("FaceDetectionEvent", (faceEvent) => {
                    updateFaceDetectionUI(faceEvent);
                    addEventLog(`Face detected: ${faceEvent.faceAttributes.sex}, ${faceEvent.faceAttributes.age} years`);
                });

                connection.on("AttendanceLogged", (attendance) => {
                    addEventLog(`✅ Attendance logged: ${attendance.userName} (${attendance.similarity}%)`, 'success');
                });

                connection.on("HealthCheck", (healthInfo) => {
                    updateHealthStatus(healthInfo);
                });
                connection.on("TrafficJunctionEvent", (trafficEvent) => {
                    updateTrafficJunctionUI(trafficEvent);
                    addEventLog(`Traffic violation: ${trafficEvent.vehicleInfo.plateNumber} - ${trafficEvent.violationInfo.violationType}`, 'warning');
                });
                    connection.on("VehicleDetected", (event) => {
                        console.log(event);
            // Update channel-specific event count
            updateChannelEventCount(event.junctionId,
                                  parseInt(document.getElementById(`event-count-${event.junctionId}`).textContent) + 1,
                                  event.eventTime);

            // Add to event log
            addEventLog(`Channel ${event.junctionId}: ${event.vehicleType} detected moving ${event.direction}`);
        });



                connection.onreconnecting((error) => {
                    addEventLog('Connection lost. Reconnecting...', 'warning');
                    updateConnectionStatus(false);
                    console.log('SignalR reconnecting due to:', error);
                });

                connection.onreconnected((connectionId) => {
                    addEventLog('Connection restored', 'success');
                    updateConnectionStatus(true);
                    reconnectAttempts = 0;
                    // Rejoin group after reconnection
                    connection.invoke("JoinFaceRecognitionGroup").catch(err => {
                        console.error('Failed to rejoin group:', err);
                    });
                });

                connection.onclose((error) => {
                    addEventLog('Connection closed', 'danger');
                    updateConnectionStatus(false);

                    if (!isManuallyDisconnected && reconnectAttempts < maxReconnectAttempts) {
                        reconnectAttempts++;
                        const delay = Math.min(1000 * Math.pow(2, reconnectAttempts), 30000);
                        addEventLog(`Attempting to reconnect in ${delay/1000}s... (${reconnectAttempts}/${maxReconnectAttempts})`, 'warning');

                        setTimeout(() => {
                            initializeSignalR();
                        }, delay);
                    } else if (!isManuallyDisconnected) {
                        addEventLog('Max reconnection attempts reached. Please refresh the page.', 'danger');
                    }
                });

                await connection.start();
                await connection.invoke("JoinFaceRecognitionGroup");

                // Test the connection
                const pingResult = await connection.invoke("Ping");
                console.log('Ping test:', pingResult);

                reconnectAttempts = 0;

            } catch (err) {
                console.error('SignalR connection error:', err);
                addEventLog('Failed to establish real-time connection', 'danger');

                if (!isManuallyDisconnected && reconnectAttempts < maxReconnectAttempts) {
                    reconnectAttempts++;
                    const delay = Math.min(1000 * Math.pow(2, reconnectAttempts), 30000);
                    setTimeout(() => initializeSignalR(), delay);
                }
            }
        }

                // Add UI update function for traffic events
        function updateTrafficJunctionUI(trafficEvent) {
            // Create or update traffic violation section in your UI
            const trafficSection = document.getElementById('trafficViolations') || createTrafficSection();

            const violationHtml = `
                <div class="card mb-3 border-warning">
                    <div class="card-header bg-warning text-dark">
                        <h6 class="mb-0">
                            <i class="fas fa-car-crash"></i> Traffic Violation
                            <span class="badge bg-danger float-end">${trafficEvent.violationInfo.violationType}</span>
                        </h6>
                    </div>
                    <div class="card-body">
                        <div class="row">
                            <div class="col-md-4">
                                ${trafficEvent.globalImageBase64 ?
                                    `<img src="data:image/jpeg;base64,${trafficEvent.globalImageBase64}" class="img-fluid rounded" alt="Scene">` :
                                    '<div class="text-muted">No scene image</div>'}
                            </div>
                            <div class="col-md-4">
                                ${trafficEvent.vehicleInfo.vehicleImageBase64 ?
                                    `<img src="data:image/jpeg;base64,${trafficEvent.vehicleInfo.vehicleImageBase64}" class="img-fluid rounded" alt="Vehicle">` :
                                    '<div class="text-muted">No vehicle image</div>'}
                            </div>
                            <div class="col-md-4">
                                <table class="table table-sm">
                                    <tr><td>Plate:</td><td><strong>${trafficEvent.vehicleInfo.plateNumber}</strong></td></tr>
                                    <tr><td>Vehicle:</td><td>${trafficEvent.vehicleInfo.vehicleType}</td></tr>
                                    <tr><td>Color:</td><td>${trafficEvent.vehicleInfo.color}</td></tr>
                                    <tr><td>Speed:</td><td>${trafficEvent.vehicleInfo.speed} km/h</td></tr>
                                    <tr><td>Junction:</td><td>${trafficEvent.junctionInfo.junctionName}</td></tr>
                                    <tr><td>Lane:</td><td>${trafficEvent.violationInfo.laneNumber}</td></tr>
                                    <tr><td>Confidence:</td><td>${(trafficEvent.violationInfo.confidence * 100).toFixed(1)}%</td></tr>
                                </table>
                            </div>
                        </div>
                    </div>
                    <div class="card-footer text-muted small">
                        ${new Date(trafficEvent.eventTime).toLocaleString()}
                    </div>
                </div>
            `;

            trafficSection.innerHTML = violationHtml + trafficSection.innerHTML;
        }

        function createTrafficSection() {
            const section = document.createElement('div');
            section.id = 'trafficViolations';
            section.className = 'mt-4';
            section.innerHTML = '<h5><i class="fas fa-traffic-light"></i> Traffic Violations</h5>';
            document.querySelector('.card-body').appendChild(section);
            return section;
        }


         function updateConnectionStatus(connected) {
            const statusElement = document.getElementById('connectionStatus');
            if (statusElement) {
                if (connected) {
                    statusElement.innerHTML = '<i class="fas fa-circle text-success"></i> Connected';
                    statusElement.className = 'text-success';
                } else {
                    statusElement.innerHTML = '<i class="fas fa-circle text-danger"></i> Disconnected';
                    statusElement.className = 'text-danger';
                }
            }
        }

        function updateHealthStatus(healthInfo) {
            // Update health information in UI if needed
            console.log('Health check:', healthInfo);
        }

        // Manual connection control
        function disconnectSignalR() {
            isManuallyDisconnected = true;
            if (connection) {
                connection.stop().then(() => {
                    addEventLog('Manually disconnected from real-time updates', 'info');
                    updateConnectionStatus(false);
                });
            }
        }

        function reconnectSignalR() {
            isManuallyDisconnected = false;
            reconnectAttempts = 0;
            initializeSignalR();
        }

        // Add connection controls to your HTML
        function addConnectionControls() {
            const controls = `
                <div class="row mb-3">
                    <div class="col-12">
                        <div class="card">
                            <div class="card-body py-2">
                                <div class="d-flex justify-content-between align-items-center">
                                    <div>
                                        <span id="connectionStatus" class="text-success">
                                            <i class="fas fa-circle"></i> Connected
                                        </span>
                                        <small class="text-muted ms-2" id="connectionDetails">
                                            Real-time updates active
                                        </small>
                                    </div>
                                    <div>
                                        <button id="reconnectBtn" class="btn btn-sm btn-outline-primary me-2" onclick="reconnectSignalR()">
                                            <i class="fas fa-sync-alt"></i> Reconnect
                                        </button>
                                        <button id="disconnectBtn" class="btn btn-sm btn-outline-secondary" onclick="disconnectSignalR()">
                                            <i class="fas fa-plug"></i> Disconnect
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            `;

            const cardHeader = document.querySelector('.card-header');
            cardHeader.insertAdjacentHTML('afterend', controls);
        }


         // Update UI for face recognition events
         function updateFaceRecognitionUI(faceEvent) {
             // Update images
             updateImage('globalImage', 'noGlobalImage', faceEvent.globalImageBase64);
             updateImage('faceImage', 'noFaceImage', faceEvent.faceImageBase64);
             updateImage('candidateImage', 'noCandidateImage', faceEvent.candidateImageBase64);

             // Update face attributes
             if (faceEvent.faceAttributes) {
                 document.getElementById('faceSex').textContent = faceEvent.faceAttributes.sex || '-';
                 document.getElementById('faceAge').textContent = faceEvent.faceAttributes.age || '-';
                 document.getElementById('faceSkinColor').textContent = faceEvent.faceAttributes.skinColor || '-';
                 document.getElementById('faceEye').textContent = faceEvent.faceAttributes.eyeState || '-';
                 document.getElementById('faceMouth').textContent = faceEvent.faceAttributes.mouthState || '-';
                 document.getElementById('faceMask').textContent = faceEvent.faceAttributes.maskState || '-';
                 document.getElementById('faceBeard').textContent = faceEvent.faceAttributes.beardState || '-';
                 document.getElementById('faceQuality').textContent = faceEvent.faceAttributes.faceQuality || '-';
             }

             // Update candidate info
             if (faceEvent.candidateInfo) {
                 document.getElementById('candidateName').textContent = faceEvent.candidateInfo.name || '-';
                 document.getElementById('candidateId').textContent = faceEvent.candidateInfo.id || '-';
                 document.getElementById('candidateSex').textContent = faceEvent.candidateInfo.sex || '-';
                 document.getElementById('candidateBirthday').textContent = faceEvent.candidateInfo.birthday || '-';
                 document.getElementById('candidateSimilarity').textContent = faceEvent.similarity ? faceEvent.similarity + '%' : '-';
                 document.getElementById('candidateGroupId').textContent = faceEvent.candidateInfo.groupId || '-';
                 document.getElementById('candidateGroupName').textContent = faceEvent.candidateInfo.groupName || '-';
             } else {
                 document.getElementById('candidateName').textContent = 'Unknown';
                 document.getElementById('candidateId').textContent = '-';
                 document.getElementById('candidateSex').textContent = '-';
                 document.getElementById('candidateBirthday').textContent = '-';
                 document.getElementById('candidateSimilarity').textContent = 'Stranger';
                 document.getElementById('candidateGroupId').textContent = '-';
                 document.getElementById('candidateGroupName').textContent = '-';
             }
         }

         // Update UI for face detection events
         function updateFaceDetectionUI(faceEvent) {
             updateImage('globalImage', 'noGlobalImage', faceEvent.globalImageBase64);
             updateImage('faceImage', 'noFaceImage', null); // Clear face image for detection events
             updateImage('candidateImage', 'noCandidateImage', null); // Clear candidate image

             if (faceEvent.faceAttributes) {
                 document.getElementById('faceSex').textContent = faceEvent.faceAttributes.sex || '-';
                 document.getElementById('faceAge').textContent = faceEvent.faceAttributes.age || '-';
                 document.getElementById('faceSkinColor').textContent = faceEvent.faceAttributes.skinColor || '-';
                 document.getElementById('faceEye').textContent = faceEvent.faceAttributes.eyeState || '-';
                 document.getElementById('faceMouth').textContent = faceEvent.faceAttributes.mouthState || '-';
                 document.getElementById('faceMask').textContent = faceEvent.faceAttributes.maskState || '-';
                 document.getElementById('faceBeard').textContent = faceEvent.faceAttributes.beardState || '-';
                 document.getElementById('faceQuality').textContent = faceEvent.faceAttributes.faceQuality || '-';
             }

             // Clear candidate info for detection events
             document.getElementById('candidateName').textContent = 'Unknown';
             document.getElementById('candidateId').textContent = '-';
             document.getElementById('candidateSex').textContent = '-';
             document.getElementById('candidateBirthday').textContent = '-';
             document.getElementById('candidateSimilarity').textContent = 'Detection Only';
             document.getElementById('candidateGroupId').textContent = '-';
             document.getElementById('candidateGroupName').textContent = '-';
         }

         function updateImage(imgElementId, noImgElementId, base64Data) {
             const imgElement = document.getElementById(imgElementId);
             const noImgElement = document.getElementById(noImgElementId);

             if (base64Data) {
                 imgElement.src = 'data:image/jpeg;base64,' + base64Data;
                 imgElement.style.display = 'block';
                 noImgElement.style.display = 'none';
             } else {
                 imgElement.style.display = 'none';
                 noImgElement.style.display = 'block';
             }
         }

        // Elements
        const startBtn = document.getElementById('startBtn');
        const stopBtn = document.getElementById('stopBtn');
        const channelSelect = document.getElementById('channelSelect');
        const statusText = document.getElementById('statusText');
        const analyzerId = document.getElementById('analyzerId');

        // Image elements
        const globalImage = document.getElementById('globalImage');
        const faceImage = document.getElementById('faceImage');
        const candidateImage = document.getElementById('candidateImage');
        const noGlobalImage = document.getElementById('noGlobalImage');
        const noFaceImage = document.getElementById('noFaceImage');
        const noCandidateImage = document.getElementById('noCandidateImage');
        async function startRecog(channel){
            const _startBtn = document.querySelector(`#channel-${channel} .start-btn`);
            const originalText = _startBtn.innerHTML;

            try {
                _startBtn.innerHTML = '<span class="spinner-border spinner-border-sm" role="status"></span> Starting...';
                _startBtn.disabled = true;
                const response = await fetch('/FaceRecognition/StartRecognition', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ channel: channel })
                });

                const result = await response.json();

                if (result.success) {
                      await checkChannelStatus(channel);
                    updateChannelState(channel, true);
                    addEventLog(`Face recognition started on channel ${channel}`);
                    updateActiveChannelsCount();
                } else {
                    alert('Error: ' + result.message);
                     await checkChannelStatus(channel);
                }
            } catch (error) {
                console.error('Error starting recognition:', error);
                alert('Error starting face recognition on channel ' + channel);
                  await checkChannelStatus(channel);
            } finally {
                _startBtn.innerHTML = originalText;
                _startBtn.disabled = false;
            }
        }
                async function stopRecog(channel) {
                         const _stopBtn = document.querySelector(`#channel-${channel} .stop-btn`);
                         const originalText = _stopBtn.innerHTML;
            try {
                 _stopBtn.innerHTML = '<span class="spinner-border spinner-border-sm" role="status"></span> Stopping...';
                 _stopBtn.disabled = true;
                const response = await fetch('/FaceRecognition/StopRecognition', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ channel: channel })
                });

                const result = await response.json();

                if (result.success) {
                      // Refresh the channel status to get updated stats
                      await checkChannelStatus(channel);
                    updateChannelState(channel, false);
                    addEventLog(`Face recognition stopped on channel ${channel}`);
                    updateActiveChannelsCount();
                } else {
                    alert('Error: ' + result.message);
                    // Refresh status to ensure UI is correct
                    await checkChannelStatus(channel);
                }
            } catch (error) {
                console.error('Error stopping recognition:', error);
                alert('Error stopping face recognition on channel ' + channel);
                 // Refresh status to ensure UI is correct
                 await checkChannelStatus(channel);
                } finally {
                    _stopBtn.innerHTML = originalText;
                    _stopBtn.disabled = false;
                }
        }
        // Start face recognition
        if(startBtn){
            startBtn.addEventListener('click', startRecog);
        }
            // Stop face recognition
            if(stopBtn){
            stopBtn.addEventListener('click', async () => {
                try {
                    const response = await fetch('/FaceRecognition/StopRecognition', {
                        method: 'POST'
                    });

                    const result = await response.json();

                    if (result.success) {
                        setRunningState(false);
                        stopStatusChecking();
                        addEventLog('Face recognition stopped');
                    } else {
                        alert('Error: ' + result.message);
                    }
                } catch (error) {
                    console.error('Error stopping recognition:', error);
                    alert('Error stopping face recognition');
                }
            });
            }

                    // Start selected channel from dropdown
        function startSelectedChannel() {
            const channelSelect = document.getElementById('channelSelect');
            const channel = parseInt(channelSelect.value);
            startRecog(channel);
        }

            // Start all channels
        async function startAllChannels() {
            for (const channel of CHANNELS) {
                await startRecog(channel);
                // Small delay between starting channels to avoid overwhelming the system
                await new Promise(resolve => setTimeout(resolve, 500));
            }
        }

        // Stop all channels
        async function stopAllChannels() {
            for (const channel of CHANNELS) {
                await stopRecog(channel);
                // Small delay between stopping channels
                await new Promise(resolve => setTimeout(resolve, 500));
            }
        }

                // Check status for a specific channel
        async function checkChannelStatus(channel) {
            try {
                const response = await fetch(`/FaceRecognition/GetChannelStatus?channel=${channel}`);

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const result = await response.json();

                if (result.success) {
                    updateChannelState(channel, result.data.isRunning);
                    updateChannelStats(result.data);
                    return result.data;
                } else {
                    console.error(`Error getting status for channel ${channel}:`, result.error);
                    return null;
                }
            } catch (error) {
                console.error(`Error checking channel ${channel} status:`, error);
                return null;
            }
        }

        // Update channel statistics in the UI
        function updateChannelStats(channelData) {
            const eventCountElement = document.getElementById(`event-count-${channelData.channel}`);
            const lastEventElement = document.getElementById(`last-event-${channelData.channel}`);

            if (eventCountElement && channelData.eventCount !== undefined) {
                eventCountElement.textContent = channelData.eventCount;
            }

            if (lastEventElement && channelData.lastActivity) {
                const lastActivity = new Date(channelData.lastActivity);
                lastEventElement.textContent = lastActivity.toLocaleTimeString();
                lastEventElement.title = lastActivity.toLocaleString();
            }

            // Update start time if available
            const startTimeElement = document.getElementById(`start-time-${channelData.channel}`);
            if (startTimeElement && channelData.startTime) {
                const startTime = new Date(channelData.startTime);
                startTimeElement.textContent = startTime.toLocaleTimeString();
                startTimeElement.title = startTime.toLocaleString();
            }
        }

        // Update channel UI state
        function updateChannelState(channel, isRunning) {
            const channelElement = document.getElementById(`channel-${channel}`);
            const statusIndicator = channelElement.querySelector('.status-indicator');
            const statusBadge = channelElement.querySelector('.badge');
            const startBtn = channelElement.querySelector('.start-btn');
            const stopBtn = channelElement.querySelector('.stop-btn');
            const statusText = channelElement.querySelector(`#channel-status-${channel}`);

            if (isRunning) {
                channelElement.classList.remove('stopped');
                channelElement.classList.add('running');
                statusIndicator.classList.remove('status-stopped');
                statusIndicator.classList.add('status-running');
                statusBadge.className = 'badge bg-success';
                statusBadge.textContent = 'Running';
                startBtn.disabled = true;
                stopBtn.disabled = false;
                statusText.textContent = 'Active';
                statusText.className = 'fw-bold text-success';
            } else {
                channelElement.classList.remove('running');
                channelElement.classList.add('stopped');
                statusIndicator.classList.remove('status-running');
                statusIndicator.classList.add('status-stopped');
                statusBadge.className = 'badge bg-secondary';
                statusBadge.textContent = 'Stopped';
                startBtn.disabled = false;
                stopBtn.disabled = true;
                statusText.textContent = 'Inactive';
                statusText.className = 'fw-bold text-secondary';
            }
        }
                // Update event count for a channel
        function updateChannelEventCount(channel, eventCount, lastEventTime) {
            const eventCountElement = document.getElementById(`event-count-${channel}`);
            const lastEventElement = document.getElementById(`last-event-${channel}`);

            if (eventCountElement) {
                eventCountElement.textContent = eventCount;
            }

            if (lastEventElement && lastEventTime) {
                lastEventElement.textContent = new Date(lastEventTime).toLocaleTimeString();
            }
        }

        // Check status of all channels periodically
        async function checkAllChannelsStatus() {
            try {
                const response = await fetch('/FaceRecognition/GetRunningChannels');
                const result = await response.json();

                if (result.success) {
                    // Update UI based on running channels
                    CHANNELS.forEach(channel => {
                        const isRunning = result.channels.includes(channel);
                        updateChannelState(channel, isRunning);
                    });
                    updateActiveChannelsCount();
                }
            } catch (error) {
                console.error('Error checking channels status:', error);
            }
        }

        // Update active channels count
        function updateActiveChannelsCount() {
            const activeChannels = document.querySelectorAll('.channel-card.running').length;
            document.getElementById('activeChannelsCount').textContent = activeChannels;
        }

        // Check device status
        async function checkDeviceStatus() {
            try {
                // You'll need to implement this endpoint in your controller
                const response = await fetch('/Device/Status');
                const result = await response.json();

                const deviceStatusElement = document.getElementById('deviceStatus');
                if (result.isConnected) {
                    deviceStatusElement.className = 'badge bg-success';
                    deviceStatusElement.textContent = 'Connected';
                } else {
                    deviceStatusElement.className = 'badge bg-danger';
                    deviceStatusElement.textContent = 'Disconnected';
                }
            } catch (error) {
                console.error('Error checking device status:', error);
                document.getElementById('deviceStatus').className = 'badge bg-warning';
                document.getElementById('deviceStatus').textContent = 'Error';
            }
        }




            // Set running state UI
            function setRunningState(running) {
                isRunning = running;
                startBtn.disabled = running;
                stopBtn.disabled = !running;
                channelSelect.disabled = running;

                if (running) {
                    statusText.textContent = 'Running';
                    statusText.className = 'text-success';
                } else {
                    statusText.textContent = 'Stopped';
                    statusText.className = 'text-danger';
                    clearImages();
                    clearData();
                }
            }

            // Clear images
            function clearImages() {
                globalImage.style.display = 'none';
                faceImage.style.display = 'none';
                candidateImage.style.display = 'none';
                noGlobalImage.style.display = 'block';
                noFaceImage.style.display = 'block';
                noCandidateImage.style.display = 'block';
            }

            // Clear data tables
            function clearData() {
                document.getElementById('faceSex').textContent = '-';
                document.getElementById('faceAge').textContent = '-';
                document.getElementById('faceSkinColor').textContent = '-';
                document.getElementById('faceEye').textContent = '-';
                document.getElementById('faceMouth').textContent = '-';
                document.getElementById('faceMask').textContent = '-';
                document.getElementById('faceBeard').textContent = '-';
                document.getElementById('faceQuality').textContent = '-';

                document.getElementById('candidateName').textContent = '-';
                document.getElementById('candidateId').textContent = '-';
                document.getElementById('candidateSex').textContent = '-';
                document.getElementById('candidateBirthday').textContent = '-';
                document.getElementById('candidateSimilarity').textContent = '-';
                document.getElementById('candidateGroupId').textContent = '-';
                document.getElementById('candidateGroupName').textContent = '-';
            }

            // Status checking
            function startStatusChecking() {
                //statusCheckInterval = setInterval(checkStatus, 2000);
                statusCheckInterval = setInterval(() => {
                          checkStatus();
                          checkAllChannelsStatus();
                          checkDeviceStatus();
                      }, 5000);
            }

            function stopStatusChecking() {
                if (statusCheckInterval) {
                    clearInterval(statusCheckInterval);
                }
            }

            async function checkStatus() {
                try {
                    const response = await fetch('/FaceRecognition/GetStatus');
                    const status = await response.json();

                    analyzerId.textContent = status.analyzerID || '-';

                    // Here you would typically set up SignalR for real-time events
                    // For now, we'll just update status
                } catch (error) {
                    console.error('Error checking status:', error);
                }
            }

            // Event logging with types
             function addEventLog(message, type = 'info') {
                 const eventLog = document.getElementById('eventLog');
                 const timestamp = new Date().toLocaleTimeString();
                 const logEntry = document.createElement('div');
                 logEntry.className = 'event-log-item';

                 let bgClass = '';
                 switch (type) {
                     case 'success': bgClass = 'text-success'; break;
                     case 'warning': bgClass = 'text-warning'; break;
                     case 'danger': bgClass = 'text-danger'; break;
                     default: bgClass = 'text-muted';
                 }

                 logEntry.innerHTML = `<small class="${bgClass}">[${timestamp}] ${message}</small>`;
                      logEntry.innerHTML += `<br>
            <span class="event-log-time">[${timestamp}]</span>
            <span class="event-log-message">${message}</span>
        `;

                 if (eventLog.firstChild && eventLog.firstChild.className === 'text-muted') {
                     eventLog.innerHTML = '';
                 }

                 eventLog.appendChild(logEntry);
                 eventLog.scrollTop = eventLog.scrollHeight;
             }
                     function clearEventLog() {
            document.getElementById('eventLog').innerHTML = '<div class="text-muted">No events yet...</div>';
        }
                     // Initialize the channels grid
        function initializeChannelsGrid() {
            const grid = document.getElementById('channelsGrid');
            grid.innerHTML = '';

            CHANNELS.forEach(channel => {
                const channelCard = createChannelCard(channel);
                grid.appendChild(channelCard);
            });
        }

                // Create individual channel card with enhanced stats
        function createChannelCard(channel) {
            const col = document.createElement('div');
            col.className = 'col-md-6 col-lg-4 mb-3';
            col.innerHTML = `
                <div class="card channel-card stopped" data-channel="${channel}" id="channel-${channel}">
                    <div class="card-header d-flex justify-content-between align-items-center">
                        <span>
                            <span class="status-indicator status-stopped"></span>
                            Channel ${channel}
                        </span>
                        <span class="badge bg-secondary">Stopped</span>
                    </div>
                    <div class="card-body">
                        <div class="channel-stats mb-3">
                            <div class="stat-item d-flex justify-content-between">
                                <small class="text-muted">Status:</small>
                                <span class="fw-bold" id="channel-status-${channel}">Inactive</span>
                            </div>
                            <div class="stat-item d-flex justify-content-between">
                                <small class="text-muted">Events:</small>
                                <span class="fw-bold" id="event-count-${channel}">0</span>
                            </div>
                            <div class="stat-item d-flex justify-content-between">
                                <small class="text-muted">Last Event:</small>
                                <span class="fw-bold" id="last-event-${channel}" title="Never">Never</span>
                            </div>
                            <div class="stat-item d-flex justify-content-between">
                                <small class="text-muted">Uptime:</small>
                                <span class="fw-bold" id="start-time-${channel}" title="Not started">-</span>
                            </div>
                        </div>
                        <div class="btn-group w-100">
                            <button type="button" class="btn btn-success btn-channel start-btn"
                                    onclick="startRecog(${channel})" data-channel="${channel}">
                                Start
                            </button>
                            <button type="button" class="btn btn-danger btn-channel stop-btn"
                                    onclick="stopRecog(${channel})" data-channel="${channel}" disabled>
                                Stop
                            </button>
                            <button type="button" class="btn btn-info btn-channel refresh-btn"
                                    onclick="refreshChannelStatus(${channel})" data-channel="${channel}" title="Refresh Status">
                                <i class="bi bi-arrow-clockwise"></i>
                            </button>
                        </div>
                    </div>
                    <div class="card-footer text-muted text-center">
                        <small>Last checked: <span id="last-checked-${channel}">Never</span></small>
                    </div>
                </div>
            `;
            return col;
        }

        // Refresh individual channel status
        async function refreshChannelStatus(channel) {
            const refreshBtn = document.querySelector(`#channel-${channel} .refresh-btn`);
            const originalHtml = refreshBtn.innerHTML;

            // Add loading indicator
            refreshBtn.innerHTML = '<i class="bi bi-arrow-clockwise spin"></i>';
            refreshBtn.disabled = true;

            try {
                const status = await checkChannelStatus(channel);

                // Update last checked timestamp
                const lastCheckedElement = document.getElementById(`last-checked-${channel}`);
                if (lastCheckedElement) {
                    lastCheckedElement.textContent = new Date().toLocaleTimeString();
                }

                if (status) {
                    addEventLog(`Refreshed status for channel ${channel}: ${status.isRunning ? 'Running' : 'Stopped'}`);
                }
            } finally {
                // Restore button state
                refreshBtn.innerHTML = originalHtml;
                refreshBtn.disabled = false;
            }
        }

             // Initialize when page loads
             document.addEventListener('DOMContentLoaded', async function() {
                addConnectionControls();
                await initializeSignalR();
                clearImages();
                clearData();

                // MC Start
                     initializeChannelsGrid();
                     startStatusChecking();
                     checkDeviceStatus();
                // MC End

                // Add cleanup when leaving page
                window.addEventListener('beforeunload', () => {
                    isManuallyDisconnected = true;
                    if (connection) {
                        connection.stop();
                    }
                });
             });
    </script>
}